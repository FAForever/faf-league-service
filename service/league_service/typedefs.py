from enum import Enum
from typing import Callable, Dict, List, NamedTuple, Optional, Tuple

from ..decorators import with_logger


class LeagueServiceError(Exception):
    pass


class ServiceNotReadyError(LeagueServiceError):
    pass


class DivisionDoesNotExistError(LeagueServiceError):
    pass


class InvalidScoreError(LeagueServiceError):
    """Raised when trying to persist a malformed score."""

    pass


GameID = int
PlayerID = int
RatingType = str  # e.g. "ladder_1v1"
Rating = Tuple[float, float]


class GameOutcome(Enum):
    VICTORY = "VICTORY"
    DEFEAT = "DEFEAT"
    DRAW = "DRAW"
    MUTUAL_DRAW = "MUTUAL_DRAW"
    UNKNOWN = "UNKNOWN"
    CONFLICTING = "CONFLICTING"


class LeagueDivision(NamedTuple):
    id: int
    min_rating: float
    max_rating: float
    highest_score: int


@with_logger
class League(NamedTuple):
    name: str
    divisions: List[LeagueDivision]
    current_season_id: int
    placement_games: int
    placement_games_returning_player: int
    rating_type: str

    def get_division(self, division_id):
        for div in self.divisions:
            if div.id == division_id:
                return div
        self._logger.warning("Could not find a division with id %s", division_id)
        return None

    def _get_division_index(self, division_id):
        return next(
            (i for (i, div) in enumerate(self.divisions) if div.id == division_id),
            [None],
        )

    def get_next_lower_division(self, division_id: int) -> Optional[int]:
        i = self._get_division_index(division_id)
        if i == 0:
            return None
        else:
            return self.divisions[i - 1]

    def get_next_higher_division(self, division_id: int) -> Optional[int]:
        i = self._get_division_index(division_id)
        if i == len(self.divisions) - 1:
            return None
        else:
            return self.divisions[i + 1]

    def get_accumulated_score(self, division_id, score):
        my_division_index = self._get_division_index(division_id)
        return score + sum(
            div.highest_score for div in self.divisions[:my_division_index]
        )

    def get_highest_division(self):
        return self.divisions[-1]

    def get_lowest_division(self):
        return self.divisions[0]


class LeagueScore(NamedTuple):
    division_id: int
    score: int
    game_count: int
    returning_player: bool

    def __eq__(self, other) -> bool:
        return (
            isinstance(other, LeagueScore)
            and self.division_id == other.division_id
            and self.score == other.score
            and self.game_count == other.game_count
            and self.returning_player == other.returning_player
        )


class LeagueRatingRequest(NamedTuple):
    """
    Minimal information to recalculate league score after a finished game.
    Includes a callback to acknowledge processing.
    """

    game_id: GameID
    player_id: PlayerID
    rating_type: RatingType
    rating: Rating
    outcome: GameOutcome
    callback: Optional[Callable]

    @classmethod
    def from_rating_change_dict(cls, message: Dict):
        return cls(
            message["game_id"],
            message["player_id"],
            message["rating_type"],
            (message["new_rating_mean"], message["new_rating_deviation"]),
            getattr(GameOutcome, message["outcome"]),
            message.get("_ack"),
        )
